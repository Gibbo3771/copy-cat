--- original\Cobalt\src\main\java\org\squiddev\cobalt\LuaThread.java
+++ src\main\java\org\squiddev\cobalt\LuaThread.java
@@ -30,11 +30,10 @@
 import org.squiddev.cobalt.function.LuaFunction;
 import org.squiddev.cobalt.lib.CoroutineLib;
 import org.squiddev.cobalt.lib.jse.JsePlatform;
+import org.teavm.interop.Sync;
 
 import java.lang.ref.WeakReference;
 import java.util.Objects;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.Condition;
 
 import static org.squiddev.cobalt.debug.DebugFrame.FLAG_ERROR;
 import static org.squiddev.cobalt.debug.DebugFrame.FLAG_YPCALL;
@@ -60,12 +59,6 @@
  */
 public class LuaThread extends LuaValue {
 	/**
-	 * Interval in nanoseconds at which to check for lua threads that are no longer referenced.
-	 * This can be changed by Java startup code if desired.
-	 */
-	public static long orphanCheckInterval = TimeUnit.SECONDS.toNanos(30);
-
-	/**
 	 * A coroutine which has been run at all
 	 */
 	private static final int STATUS_INITIAL = 0;
@@ -262,29 +255,10 @@
 		if (state.currentThread.state.javaCount == 0) {
 			throw UnwindThrowable.yield(args);
 		} else {
-			try {
-				return yieldBlockingImpl(state, args);
-			} catch (InterruptedException e) {
-				throw new InterruptedError(e);
-			}
+			throw new LuaError("attempt to yield across a call boundary");
 		}
 	}
 
-	/**
-	 * Yield the current thread and wait for a response
-	 *
-	 * @param state The current lua state
-	 * @param args  The arguments to send as return values to {@link #resume(LuaState, LuaThread, Varargs)}
-	 * @return The values this coroutine was resumed with
-	 * @throws LuaError             If this thread cannot be yielded.
-	 * @throws InterruptedException If this thread was terminated when yielding.
-	 */
-	public static Varargs yieldBlocking(LuaState state, Varargs args) throws LuaError, InterruptedException {
-		Objects.requireNonNull(args, "args cannot be null");
-		checkYield(state);
-		return yieldBlockingImpl(state, args);
-	}
-
 	private static void checkYield(LuaState state) throws LuaError {
 		LuaThread thread = state.currentThread;
 		if (thread.state.status != STATUS_RUNNING) {
@@ -293,16 +267,6 @@
 		if (thread.isMainThread()) throw new LuaError("cannot yield main thread");
 	}
 
-	private static Varargs yieldBlockingImpl(LuaState state, Varargs args) throws InterruptedException, LuaError {
-		State current = state.currentThread.state;
-
-		// Mark the parent coroutine as "active" and transfer.
-		state.currentThread = current.previousThread;
-		current.status = STATUS_SUSPENDED;
-		current.previousThread = null;
-		return transferControl(state, current, args);
-	}
-
 	/**
 	 * Resume a thread with arguments.
 	 *
@@ -328,20 +292,7 @@
 		if (currentState.javaCount == 0) {
 			throw UnwindThrowable.resume(thread, args);
 		} else {
-			try {
-				// Mark the child coroutine as "active", and transfer.
-				state.currentThread = thread;
-				currentState.status = STATUS_NORMAL;
-				threadState.previousThread = current;
-
-				// Null these out to ensure they do not hang around on the stack
-				//noinspection UnusedAssignment
-				thread = current = null;
-
-				return transferControl(state, currentState, args);
-			} catch (InterruptedException e) {
-				throw new InterruptedError(e);
-			}
+			throw new LuaError("attempt to resume across a call boundary");
 		}
 	}
 
@@ -361,58 +312,10 @@
 		if (current.javaCount == 0) {
 			throw UnwindThrowable.suspend();
 		} else {
-			suspendBlocking(state);
+			throw new LuaError("attempt to yield across a call boundary");
 		}
 	}
 
-	/**
-	 * Suspend the current thread and wait for it to be resumed.
-	 *
-	 * @param state The current lua state
-	 * @throws LuaError If this coroutine cannot be suspended.
-	 */
-	public static void suspendBlocking(LuaState state) throws LuaError {
-		State current = state.currentThread.state;
-		if (current.status != STATUS_RUNNING) {
-			throw new LuaError("cannot suspend a " + STATUS_NAMES[current.status] + " thread");
-		}
-
-		try {
-			// Mark the child coroutine as "active", and transfer.
-			current.status = STATUS_SUSPENDED;
-			state.threader.running = false;
-			transferControl(state, current, null);
-		} catch (InterruptedException e) {
-			throw new InterruptedError(e);
-		}
-	}
-
-	private static Varargs transferControl(LuaState state, State thread, Varargs args) throws InterruptedException, LuaError {
-		YieldThreader threader = state.threader;
-
-		// Construct a lock to wait on.
-		if (thread.resumeLock == null) thread.resumeLock = threader.lock.newCondition();
-
-		threader.lock.lockInterruptibly();
-		try {
-			// Give the runner a signal, and start it off.
-			thread.needsThreadedResume = true;
-			threader.set(args);
-			threader.loop.signal();
-
-			// Wait for us to be resumed.
-			while (thread.resumeLock.awaitNanos(orphanCheckInterval) <= 0) {
-				if (state.abandoned) throw new InterruptedException("Abandoned state");
-				if (thread.owner.get() == null) throw new OrphanedThreadException();
-			}
-
-			return threader.unpack();
-		} finally {
-			threader.lock.unlock();
-			thread.needsThreadedResume = false;
-		}
-	}
-
 	public static Varargs runMain(LuaState state, LuaFunction function) throws LuaError, InterruptedException {
 		return run(state, state.getMainThread(), function, Constants.NONE);
 	}
@@ -434,68 +337,11 @@
 	}
 
 	private static Varargs run(final LuaState state, LuaThread thread, LuaFunction function, Varargs args) throws LuaError, InterruptedException {
-		YieldThreader threader = state.threader;
-		threader.lock.lock();
-		try {
-			// First, set up the initial state
-			state.currentThread = thread;
-			threader.set(args);
-			threader.running = true;
-
-			Runnable task = new Runnable() {
-				LuaFunction func = function;
-
-				@Override
-				public void run() {
-					try {
-						threader.lock.lockInterruptibly();
-					} catch (InterruptedException ignored) {
-						Thread.currentThread().interrupt();
-						System.out.println("Interrupted");
-						return;
-					}
-
-					try {
-						// Clear the function after the first run
-						LuaFunction function = func;
-						func = null;
-
-						Varargs res = loop(state, state.currentThread, function, threader.unpack());
-
-						// Loop returned a value, which means the top-level coroutine yielded or terminated.
-						threader.set(res);
-						threader.running = false;
-						threader.loop.signal();
-					} catch (TransferredControlThrowable ignored) {
-						// Just die here: someone else is running now, but the coroutines are still being executed.
-					} catch (Throwable e) {
-						// Loop threw a LuaError (the top-level coroutine errored) or threw an unknown exception
-						// (terminate everything).
-						threader.set(e);
-						threader.running = false;
-						threader.loop.signal();
-					} finally {
-						threader.lock.unlock();
-					}
-				}
-			};
-
-			while (threader.running && state.currentThread != null) {
-				threader.execute(task);
-				threader.loop.await();
-			}
-
-			return threader.unpack();
-		} catch (InterruptedError e) {
-			throw e.getCause();
-		} finally {
-			threader.lock.unlock();
-		}
+		return loop(state, thread, function, args);
 	}
 
-	static Varargs loop(final LuaState state, LuaThread thread, LuaFunction function, Varargs args) throws LuaError, TransferredControlThrowable {
-		YieldThreader threader = state.threader;
-
+	@Sync
+	static Varargs loop(final LuaState state, LuaThread thread, LuaFunction function, Varargs args) throws LuaError {
 		LuaError le = null;
 		do {
 			final State threadState = thread.state;
@@ -521,19 +367,6 @@
 						args = null;
 						le = LuaError.wrap(e);
 					}
-				} else if (threadState.needsThreadedResume) {
-					// We only ever resume coroutines which have yielded, never those which have
-					// resumed other coroutines. Consequently, we know we will never have an error here.
-					if (le != null) {
-						throw new IllegalStateException("Cannot resume a threaded coroutine with an error.");
-					}
-
-					// Store the arguments in threader, and resume this thread.
-					threader.set(args);
-					threadState.status = STATUS_RUNNING;
-					threadState.resumeLock.signal();
-
-					throw TransferredControlThrowable.INSTANCE;
 				} else {
 					threadState.status = STATUS_RUNNING;
 
@@ -656,16 +489,6 @@
 		int javaCount = 0;
 
 		/**
-		 * The lock to wait on while this coroutine is suspended as a thread
-		 */
-		Condition resumeLock;
-
-		/**
-		 * Whether we've yielded in a threaded manner.
-		 */
-		boolean needsThreadedResume;
-
-		/**
 		 * Constructor for main thread only
 		 */
 		State(LuaThread owner, int status) {
@@ -673,17 +496,4 @@
 			this.status = status;
 		}
 	}
-
-	/**
-	 * Used inside {@link #loop(LuaState, LuaThread, LuaFunction, Varargs)} when
-	 * this particular thread has transferred control elsewhere.
-	 */
-	private static class TransferredControlThrowable extends Throwable {
-		private static final long serialVersionUID = 6854182520592525282L;
-		static final TransferredControlThrowable INSTANCE = new TransferredControlThrowable();
-
-		private TransferredControlThrowable() {
-			super(null, null, true, false);
-		}
-	}
 }
